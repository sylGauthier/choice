#!/bin/bash

. color.sh
. cursor.sh
. keyboard.sh

print_statusbar() {
    {
        cursor_pos $(tput lines)
        color_positive
        erase_in_line 2
        [ "$timeout" -ge 0 ] && printf 'Timeout %d\r' "$timeout"
        [ -z "$userinput" ] || printf '/%s' "$userinput"
    } > /dev/tty
}

get_entry() {
    sed -n "$(($1+1))p" <<< "$filtered" | {
        IFS="$separator" read -r key val
        format="$2"
        while [ -n "$format" ]; do
            IFS="%" read -r text format <<< "$format"
            printf '%s' "$text"
            case "$format" in
                k*) printf '%s' "$key"; format="${format:1}";;
                v*) printf '%s' "$val"; format="${format:1}";;
                p*) printf '%%'; format="${format:1}";;
            esac
        done
        printf '\n'
    }
}

print_entry() {
    text="$(get_entry "$1" "$dformat")"
    cols="$(tput cols)"
    [ "$1" -eq "$entry" ] && color_negative || color_positive
    cursor_pos "$(($1+1))"
    while [ -n "$text" ]; do
        if [[ "$text" =~ ^($'\e['[0-9:;<=>?]*[!\"#$%&\'()*+,-./]*[]@A-Z[\\^_\`a-z{|}~])(.*) ]]; then
            printf '%s' "${BASH_REMATCH[1]}"
            text="${BASH_REMATCH[2]}"
        fi
        if [[ "$text" =~ ^([^$'\e']*)($'\e'.*) ]]; then
            cur="${BASH_REMATCH[1]}"
            text="${BASH_REMATCH[2]}"
        else
            cur="$text"
            text=""
        fi
        [ "$cols" -lt 3 ] && [ -n "$cur" ] && cur="$(seq "$cols" | tr -d '\n' | tr '[1-3]' '.')"
        [ "${#cur}" -gt "$cols" ] && cur="${cur:0:$((cols - 3))}..."
        printf '%s' "$cur"
        ((cols -= ${#cur}))
    done
}

print_all() {
    printf '%s' "$(erase_display 2; for (( i=0; i<size; i++)); do print_entry "$i"; done)" > /dev/tty
    print_statusbar
}

update_filtered() {
    if [ -z "$1" ]; then
        filtered="$(tail "-n+$((offset+1))" <<< "$STDIN" | head "-n$(($(tput lines)-1))")"
    else
        filtered="$(grep -i "^[^$separator]*[$separator].*$1" <<< "$STDIN" | tail "-n+$((offset+1))" | head "-n$(($(tput lines)-1))")"
    fi
    size="$(wc -l <<< "$filtered")"
}

change_entry() {
    old="$entry"
    entry="$1"
    print_entry "$old" > /dev/tty
    print_entry "$entry" > /dev/tty
}

select_entry() {
    entry="$1"
    offset=0
    userinput=""
    update_filtered "$userinput"

    cursor_hide > /dev/tty
    print_all

    while true; do
        read_key
        timeout=-1
        kill $(jobs -p) 2>/dev/null; wait $(jobs -p) 2>/dev/null
        print_statusbar
        case $KEY in
            DOWN)
                if [ "$size" -gt 0 ]; then
                    if [ "$entry" -lt "$((size-1))" ]; then
                        change_entry $((entry+1))
                    elif [ "$size" -ge "$(($(tput lines)-1))" ]; then
                        ((offset += $(($(tput lines)-1))))
                        update_filtered "$userinput"
                        entry=0
                        print_all
                    fi
                fi
                ;;
            UP)
                if [ "$size" -gt 0 ]; then
                    if [ "$entry" -gt 0 ]; then
                        change_entry $((entry-1))
                    elif [ "$offset" -gt 0 ]; then
                        ((offset -= $(($(tput lines)-1))))
                        [ "$offset" -lt 0 ] && offset=0
                        update_filtered "$userinput"
                        entry="$((size-1))"
                        print_all
                    fi
                fi
                ;;
            ENTER)
                [ "$size" -gt 0 ] && exit ;;
            [a-zA-Z])
                userinput="$userinput$KEY"
                update_filtered "$userinput"
                entry=0
                print_all
                ;;
            BACKSPACE)
                [ -z "$userinput" ] || userinput="${userinput:0:${#userinput}-1}"
                update_filtered "$userinput"
                entry=0
                print_all
                ;;
            ESC)
                filtered=""
                exit
                ;;
        esac
    done
}

index=0
timeout=-1
defaultentry=0
rformat="%k"
dformat="%v"
separator=" "

while [ $# -gt 0 ]; do
    case "$1" in
        -t|--timeout) shift; timeout="${1:-0}"; shift ;;
        -e|--default-entry) shift; defaultentry="$1"; shift ;;
        -r|--rformat) shift; rformat="$1"; shift ;;
        -d|--dformat) shift; dformat="$1"; shift ;;
        -s|--separator) shift; separator="$1"; shift ;;
        *)
            printf 'Error: invalid option "%s"\n' "$1" >&2
            exit 1
            ;;
    esac
done

STDIN="$(cat)"

[ "$timeout" -ge 0 ] && { while true; do sleep 1; kill -USR1 $$; done; } &
trap '((timeout--)); [ "$timeout" -eq 0 ] && exit; erase_in_line 2 > /dev/tty; print_statusbar' USR1
trap 'stty echo < /dev/tty; kill $(jobs -p) 2>/dev/null; wait $(jobs -p) 2>/dev/null; (cursor_show; erase_display 2; color_positive; cursor_pos) > /dev/tty; get_entry "$entry" "$rformat"' EXIT
trap print_all WINCH

select_entry "$defaultentry"
